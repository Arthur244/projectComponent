{"remainingRequest":"/Users/xujunjie/Documents/git/projectComponent/node_modules/thread-loader/dist/cjs.js??ref--11-1!/Users/xujunjie/Documents/git/projectComponent/node_modules/docz-core/node_modules/babel-loader/lib/index.js??ref--11-2!/Users/xujunjie/Documents/git/projectComponent/node_modules/source-map-loader/index.js!/Users/xujunjie/Documents/git/projectComponent/src/utils/TreeControl.ts","dependencies":[{"path":"/Users/xujunjie/Documents/git/projectComponent/src/utils/TreeControl.ts","mtime":1608989725151},{"path":"/Users/xujunjie/Documents/git/projectComponent/node_modules/cache-loader/dist/cjs.js","mtime":1609062632110},{"path":"/Users/xujunjie/Documents/git/projectComponent/node_modules/thread-loader/dist/cjs.js","mtime":1609062632658},{"path":"/Users/xujunjie/Documents/git/projectComponent/node_modules/docz-core/node_modules/babel-loader/lib/index.js","mtime":1609062558293},{"path":"/Users/xujunjie/Documents/git/projectComponent/node_modules/source-map-loader/index.js","mtime":1609062632650}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0IF9vYmplY3RTcHJlYWQgZnJvbSAiL1VzZXJzL3h1anVuamllL0RvY3VtZW50cy9naXQvcHJvamVjdENvbXBvbmVudC9ub2RlX21vZHVsZXMvYmFiZWwtcHJlc2V0LXJlYWN0LWFwcC9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0U3ByZWFkMiI7CmltcG9ydCBfY2xhc3NDYWxsQ2hlY2sgZnJvbSAiL1VzZXJzL3h1anVuamllL0RvY3VtZW50cy9naXQvcHJvamVjdENvbXBvbmVudC9ub2RlX21vZHVsZXMvYmFiZWwtcHJlc2V0LXJlYWN0LWFwcC9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY2xhc3NDYWxsQ2hlY2siOwppbXBvcnQgX2NyZWF0ZUNsYXNzIGZyb20gIi9Vc2Vycy94dWp1bmppZS9Eb2N1bWVudHMvZ2l0L3Byb2plY3RDb21wb25lbnQvbm9kZV9tb2R1bGVzL2JhYmVsLXByZXNldC1yZWFjdC1hcHAvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NyZWF0ZUNsYXNzIjsKCihmdW5jdGlvbiAoKSB7CiAgdmFyIGVudGVyTW9kdWxlID0gdHlwZW9mIHJlYWN0SG90TG9hZGVyR2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IHJlYWN0SG90TG9hZGVyR2xvYmFsLmVudGVyTW9kdWxlIDogdW5kZWZpbmVkOwogIGVudGVyTW9kdWxlICYmIGVudGVyTW9kdWxlKG1vZHVsZSk7Cn0pKCk7Cgp2YXIgX19zaWduYXR1cmVfXyA9IHR5cGVvZiByZWFjdEhvdExvYWRlckdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyByZWFjdEhvdExvYWRlckdsb2JhbFsiZGVmYXVsdCJdLnNpZ25hdHVyZSA6IGZ1bmN0aW9uIChhKSB7CiAgcmV0dXJuIGE7Cn07CgovKioKICog5LiA5Liq6YCa55So55qE5qCR57uT5p6E5pON5L2c5Zmo77yM5a+55rqQ5pWw5o2u55qE57uT5p6E5rKh5pyJ6KaB5rGCCiAqIEBhdXRob3IgeWluaHVuZmVpeHVlCiAqIEBlbWFpbCB5aW5odW5mZWl4dWVAMTYzLmNvbQogKi8KdmFyIFRyZWVDb250cm9sID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHsKICAvKioKICAgKiDliJvlu7rmoJHmjqfliLblmajlrp7kvosKICAgKiBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbn0gZGF0YUdldHRlciDojrflj5bnu5PngrnlgLznmoTmlrnms5XvvIzkuLrlrZfnrKbkuLLmiJYobm9kZSk9Pm9iamVjdOeahOWHveaVsAogICAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBjaGlsZHJlbkdldHRlciDojrflj5bnu5PngrnlrZDnu5PngrnliJfooajnmoTmlrnms5XvvIzkuLrlrZfnrKbkuLLmiJYobm9kZSk9Pm9iamVjdOeahOWHveaVsAogICAqLwogIGZ1bmN0aW9uIFRyZWVDb250cm9sKCkgewogICAgdmFyIGRhdGFHZXR0ZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6ICd2YWx1ZSc7CiAgICB2YXIgY2hpbGRyZW5HZXR0ZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6ICdjaGlsZHJlbic7CiAgICB2YXIgY2hpbGRyZW5DcmVhdGVyID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAnY2hpbGRyZW4nOwoKICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUcmVlQ29udHJvbCk7CgogICAgdGhpcy5kYXRhR2V0dGVyID0gdm9pZCAwOwogICAgdGhpcy5jaGlsZHJlbkdldHRlciA9IHZvaWQgMDsKICAgIHRoaXMuY2hpbGRyZW5DcmVhdGVyID0gdm9pZCAwOwoKICAgIGlmICghZGF0YUdldHRlcikgewogICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RhdGFHZXR0ZXIgbmVlZCB2YWx1ZScpOwogICAgfSBlbHNlIGlmICghY2hpbGRyZW5HZXR0ZXIpIHsKICAgICAgdGhyb3cgbmV3IEVycm9yKCdjaGlsZHJlbkdldHRlciBuZWVkIHZhbHVlJyk7CiAgICB9IGVsc2UgewogICAgICB0aGlzLmRhdGFHZXR0ZXIgPSBkYXRhR2V0dGVyOwogICAgICB0aGlzLmNoaWxkcmVuR2V0dGVyID0gY2hpbGRyZW5HZXR0ZXI7CiAgICAgIHRoaXMuY2hpbGRyZW5DcmVhdGVyID0gY2hpbGRyZW5DcmVhdGVyOwogICAgfQogIH0KICAvKioKICAgKiDov4fmu6TmoJEKICAgKiBAcGFyYW0gdHJlZSDmoJEKICAgKiBAcGFyYW0gZXF1YWwg5piv5ZCm5Yy56YWN55qE5pa55rOV77yM6L+U5ZuedHJ1Ze+8jOihqOekuue7k+aenOS4reWMheWQq+atpOe7k+eCueWPiuWfuuWtkOe7k+eCuQogICAqLwoKCiAgX2NyZWF0ZUNsYXNzKFRyZWVDb250cm9sLCBbewogICAga2V5OiAiZmlsdGVyIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBmaWx0ZXIodHJlZSwgZXF1YWwpIHsKICAgICAgcmV0dXJuIHRoaXMuX2ZpbHRlcklubmVyKHRyZWUsIGVxdWFsLCBudWxsKTsKICAgIH0KICB9LCB7CiAgICBrZXk6ICJfZmlsdGVySW5uZXIiLAogICAgdmFsdWU6IGZ1bmN0aW9uIF9maWx0ZXJJbm5lcih0cmVlLCBlcXVhbCwgcGFyZW50Tm9kZSkgewogICAgICBpZiAoIXRyZWUpIHsKICAgICAgICByZXR1cm4gW107CiAgICAgIH0KCiAgICAgIHZhciByZXN1bHQgPSBbXTsgLy8g5b6q546vdHJlZQogICAgICAvLyDlr7nkuo7mr4/kuIDpobnvvIzlpoLmnpxlcXVhbOi/lOWbnnRydWXvvIzmt7vliqDliLDnu5PmnpzliJfooajkuK3vvJvlkKbliJnvvIzpgJLlvZLlrZDliJfooajvvIzlpoLmnpzpgJLlvZLnmoTlrZDliJfooag+PTDvvIzmt7vliqDliLDnu5PmnpzliJfooagKCiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJlZS5sZW5ndGg7IGkrKykgewogICAgICAgIHZhciBfaXRlbSA9IF9vYmplY3RTcHJlYWQoe30sIHRyZWVbaV0pOwoKICAgICAgICBpZiAoZXF1YWwoX2l0ZW0sIGksIHBhcmVudE5vZGUpKSB7CiAgICAgICAgICByZXN1bHQucHVzaChfaXRlbSk7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHZhciBmaWx0ZXJDaGlsZHJlbiA9IHRoaXMuX2ZpbHRlcklubmVyKHRoaXMuZ2V0Q2hpbGRyZW4oX2l0ZW0pLCBlcXVhbCwgX2l0ZW0pOwoKICAgICAgICAgIGlmIChmaWx0ZXJDaGlsZHJlbiAmJiBmaWx0ZXJDaGlsZHJlbi5sZW5ndGggPiAwKSB7CiAgICAgICAgICAgIHJlc3VsdC5wdXNoKF9pdGVtKTsKCiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZUNoaWxkcmVuKF9pdGVtLCBmaWx0ZXJDaGlsZHJlbik7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CgogICAgICByZXR1cm4gcmVzdWx0OwogICAgfQogICAgLyoqCiAgICAgKiDkuIDnu7TmlbDnu4TovazmjaLmiJDmoJHnu5PmnoQKICAgICAqIEBwYXJhbSBsaXN0CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAibGlzdFRvVHJlZSIsCiAgICB2YWx1ZTogZnVuY3Rpb24gbGlzdFRvVHJlZShsaXN0LCBlcXVhbFBhcmVudCkgewogICAgICByZXR1cm4gdGhpcy5pbm5lckxpc3RUcmVlKGxpc3QsIGVxdWFsUGFyZW50LCBudWxsKTsKICAgIH0KICB9LCB7CiAgICBrZXk6ICJpbm5lckxpc3RUcmVlIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBpbm5lckxpc3RUcmVlKGxpc3QsIGVxdWFsUGFyZW50LCBwYXJlbnQpIHsKICAgICAgaWYgKCFsaXN0KSB7CiAgICAgICAgcmV0dXJuIFtdOwogICAgICB9IC8vIOW+queOr2xpc3TvvIzpkojlr7nmr4/kuIDpoblpdGVt77ya5L2/55SoZXF1YWxQYXJlbnTliKTmlq1wYXJlbnTmmK/lkKbmmK9pdGVt55qE54i257uT54K5CiAgICAgIC8vIOWmguaenOaYr++8jOWImea3u+WKoOWIsOe7k+aenOWIl+ihqO+8m+W5tuS7pWl0ZW3kuLrniLbnu5PngrnvvIzmn6Xmib7lrZDliJfooagKICAgICAgLy8g5ZCm5YiZ77yM5LiN5aSE55CGCgoKICAgICAgdmFyIHJlc3VsdCA9IFtdOwoKICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7CiAgICAgICAgdmFyIF9pdGVtMiA9IGxpc3RbaV07CgogICAgICAgIGlmIChlcXVhbFBhcmVudChfaXRlbTIsIHBhcmVudCkpIHsKICAgICAgICAgIHJlc3VsdC5wdXNoKF9pdGVtMik7CgogICAgICAgICAgdmFyIF9jaGlsZHJlbiA9IHRoaXMuaW5uZXJMaXN0VHJlZShsaXN0LCBlcXVhbFBhcmVudCwgX2l0ZW0yKTsKCiAgICAgICAgICBpZiAoX2NoaWxkcmVuICYmIF9jaGlsZHJlbi5sZW5ndGgpIHsKICAgICAgICAgICAgdGhpcy5fY3JlYXRlQ2hpbGRyZW4oX2l0ZW0yLCBfY2hpbGRyZW4pOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQoKICAgICAgcmV0dXJuIHJlc3VsdDsKICAgIH0KICAgIC8qKgogICAgICog5pCc57Si5ruh6Laz5oyH5a6a5p2h5Lu255qE56ys5LiA5Liq57uT54K5CiAgICAgKiBAcGFyYW0g5qCR57uT54K555qE5pWw5o2uCiAgICAgKiBAcGFyYW0g5Yy56YWN5Ye95pWwCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAic2VhcmNoIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBzZWFyY2godHJlZSwgZXF1YWxGdW5jdGlvbikgewogICAgICB2YXIgY2hhaW4gPSB0aGlzLl9zZWFyY2hDaGFpbklubmVyKHRyZWUsIGVxdWFsRnVuY3Rpb24pOwoKICAgICAgcmV0dXJuIGNoYWluICYmIGNoYWluLmxlbmd0aCA/IGNoYWluW2NoYWluLmxlbmd0aCAtIDFdIDogbnVsbDsKICAgIH0KICAgIC8qKgogICAgICog5pCc57Si5ruh6Laz5oyH5a6a5p2h5Lu255qE56ys5LiA5Liq57uT54K555qE54i257uT54K5CiAgICAgKiBAcGFyYW0gdHJlZSDmoJEKICAgICAqIEBwYXJhbSBlcXVhbEZ1bmN0aW9uIOWMuemFjeWHveaVsO+8jOagvOW8j+S4uihub2RlLCBpbmRleCwgcGFyZW50Tm9kZSk9PmJvb2wKICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJzZWFyY2hQYXJlbnQiLAogICAgdmFsdWU6IGZ1bmN0aW9uIHNlYXJjaFBhcmVudCh0cmVlLCBlcXVhbEZ1bmN0aW9uKSB7CiAgICAgIHZhciBjaGFpbiA9IHRoaXMuX3NlYXJjaENoYWluSW5uZXIodHJlZSwgZXF1YWxGdW5jdGlvbik7CgogICAgICBpZiAoY2hhaW4gJiYgY2hhaW4ubGVuZ3RoID49IDIpIHsKICAgICAgICByZXR1cm4gY2hhaW5bY2hhaW4ubGVuZ3RoIC0gMl07CiAgICAgIH0KCiAgICAgIHJldHVybiBudWxsOwogICAgfQogICAgLyoqCiAgICAgKiDojrflj5bmu6HotrPmjIflrprmnaHku7bnmoTnrKzkuIDkuKrnu5PngrnlnKjniLbnu5PngrnlrZDliJfooajkuK3nmoTkvY3nva7vvIzlpoLmnpzml6DniLbnu5PngrnvvIzmiJbnu5PngrnkuI3lrZjlnKjvvIzov5Tlm54tMQogICAgICogQHBhcmFtIHRyZWUg5qCRCiAgICAgKiBAcGFyYW0gZXF1YWxGdW5jdGlvbiDljLnphY3lh73mlbDvvIzmoLzlvI/kuLoobm9kZSwgaW5kZXgsIHBhcmVudE5vZGUpPT5ib29sCiAgICAgKgogICAgICogQHJldHVybiB7TnVtYmVyfSDmjIflrprmnaHku7bnmoTnu5PngrnmiYDlnKjnmoTkvY3nva4KICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJnZXRJbmRleCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SW5kZXgodHJlZSwgZXF1YWxGdW5jdGlvbikgewogICAgICB2YXIgcGFyZW50ID0gdGhpcy5zZWFyY2hQYXJlbnQodHJlZSwgZXF1YWxGdW5jdGlvbik7CgogICAgICBpZiAocGFyZW50KSB7CiAgICAgICAgdmFyIF9jaGlsZHJlbjIgPSB0aGlzLmdldENoaWxkcmVuKHBhcmVudCk7CgogICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX2NoaWxkcmVuMi5sZW5ndGg7IGkrKykgewogICAgICAgICAgaWYgKGVxdWFsRnVuY3Rpb24oX2NoaWxkcmVuMltpXSwgaSwgcGFyZW50KSkgewogICAgICAgICAgICByZXR1cm4gaTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KCiAgICAgIHJldHVybiAtMTsKICAgIH0KICB9LCB7CiAgICBrZXk6ICJhZGRBdCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkQXQodHJlZSwgZXF1YWxGdW5jdGlvbiwgY2hpbGQpIHsKICAgICAgdmFyIGluZGV4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiAtMTsKICAgICAgdmFyIG5vZGUgPSB0aGlzLnNlYXJjaCh0cmVlLCBlcXVhbEZ1bmN0aW9uKTsKCiAgICAgIGlmIChub2RlKSB7CiAgICAgICAgdmFyIF9jaGlsZHJlbjMgPSB0aGlzLmdldENoaWxkcmVuKG5vZGUpOwoKICAgICAgICBpZiAoIV9jaGlsZHJlbjMpIHsKICAgICAgICAgIF9jaGlsZHJlbjMgPSB0aGlzLl9jcmVhdGVDaGlsZHJlbihub2RlKTsKICAgICAgICB9CgogICAgICAgIGlmIChfY2hpbGRyZW4zKSB7CiAgICAgICAgICB2YXIgcmVhbEluZGV4ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oX2NoaWxkcmVuMy5sZW5ndGgsIGluZGV4KSk7CiAgICAgICAgICBfY2hpbGRyZW4zW3JlYWxJbmRleF0gPSBjaGlsZDsKICAgICAgICB9CiAgICAgIH0KICAgIH0KICB9LCB7CiAgICBrZXk6ICJyZW1vdmUiLAogICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZSh0cmVlLCBlcXVhbEZ1bmN0aW9uKSB7CiAgICAgIHRoaXMuX3JlbW92ZUlubmVyKHRyZWUsIGVxdWFsRnVuY3Rpb24pOwogICAgfQogICAgLyoqCiAgICAgKgogICAgICogQHBhcmFtIHRyZWUKICAgICAqIEBwYXJhbSBlcXVhbEZ1bmN0aW9uCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiX3JlbW92ZUlubmVyIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVtb3ZlSW5uZXIodHJlZSwgZXF1YWxGdW5jdGlvbikgewogICAgICB2YXIgcGFyZW50ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBudWxsOwoKICAgICAgaWYgKHRyZWUpIHsKICAgICAgICAvL+mBjeWOhue7k+eCuQogICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJlZS5sZW5ndGg7IGkrKykgewogICAgICAgICAgdmFyIF9ub2RlID0gdHJlZVtpXTsgLy/lpoLmnpzlvZPliY3nu5PngrnnrKblkIjooqvliKDpmaTnmoTmnaHku7bvvIzliJnliKDpmaTvvJvkuI3nrKblkIjvvIzliJnpgJLlvZLlrZDnu5PngrkKCiAgICAgICAgICBpZiAoZXF1YWxGdW5jdGlvbihfbm9kZSwgaSwgcGFyZW50KSkgewogICAgICAgICAgICB0cmVlLnNwbGljZShpLCAxKTsKICAgICAgICAgICAgaS0tOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgdGhpcy5fcmVtb3ZlSW5uZXIodGhpcy5nZXRDaGlsZHJlbihfbm9kZSksIGVxdWFsRnVuY3Rpb24sIF9ub2RlKTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KICAgIH0KICAgIC8qKgogICAgICog5pCc57Si5ruh6Laz5p2h5Lu255qE56ys5LiA5Liq57uT54K577yM5bm26L+U5Zue5LuO5LiA57qn57uT54K55Yiw5oyH5a6a57uT54K555qE5pWw57uE77yM56ys5LiA6aG55piv5LiA57qn57uT54K577yM5pyA5ZCO5LiA6aG55piv56ym5ZCI5p2h5Lu255qE57uT54K5CiAgICAgKiBAcGFyYW0gdHJlZSDmoJEKICAgICAqIEBwYXJhbSBlcXVhbEZ1bmN0aW9uIOWMuemFjeWHveaVsAogICAgICovCgogIH0sIHsKICAgIGtleTogInNlYXJjaENoYWluIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBzZWFyY2hDaGFpbih0cmVlLCBlcXVhbEZ1bmN0aW9uKSB7CiAgICAgIHJldHVybiB0aGlzLl9zZWFyY2hDaGFpbklubmVyKHRyZWUsIGVxdWFsRnVuY3Rpb24pOwogICAgfQogICAgLyoqCiAgICAgKiDpgY3ljobmoJHnu5PngrnvvIzlubblr7nmr4/kuKrnu5PngrnmiafooYzlm57osIPlh73mlbAKICAgICAqIEBwYXJhbSB7QXJyYXl9IHRyZWUg5qCRCiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmb3JFYWNoRnVuY3Rpb24g5Zue6LCD5Ye95pWwCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiZm9yRWFjaCIsCiAgICB2YWx1ZTogZnVuY3Rpb24gZm9yRWFjaCh0cmVlLCBmb3JFYWNoRnVuY3Rpb24pIHsKICAgICAgdGhpcy5fZm9yRWFjaElubmVyKHRyZWUsIGZvckVhY2hGdW5jdGlvbik7CiAgICB9CiAgICAvKioKICAgICAqIOafpeaJvuaJgOacieespuWQiOadoeS7tueahOe7k+eCue+8jOW5tui/lOWbnuespuWQiOadoeS7tue7k+eCueeahOS4gOe7tOaVsOe7hAogICAgICogQHBhcmFtIHRyZWUg5qCRCiAgICAgKiBAcGFyYW0gZXF1YWxGdW5jdGlvbiDljLnphY3lh73mlbAKICAgICAqLwoKICB9LCB7CiAgICBrZXk6ICJmaW5kIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBmaW5kKHRyZWUsIGVxdWFsRnVuY3Rpb24pIHsKICAgICAgdmFyIHJlc3VsdCA9IFtdOwogICAgICB0aGlzLmZvckVhY2godHJlZSwgZnVuY3Rpb24gKG5vZGUsIGksIHBhcmVudCkgewogICAgICAgIGlmIChlcXVhbEZ1bmN0aW9uKG5vZGUsIGksIHBhcmVudCkpIHsKICAgICAgICAgIHJlc3VsdC5wdXNoKG5vZGUpOwogICAgICAgIH0KICAgICAgfSk7CiAgICAgIHJldHVybiByZXN1bHQ7CiAgICB9CiAgICAvKioKICAgICAqIOiuoeeul+agkeeahOe7k+eCueaAu+aVsAogICAgICogQHBhcmFtIHRyZWUg5qCRCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiY291bnQiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGNvdW50KHRyZWUpIHsKICAgICAgdmFyIHJlc3VsdCA9IDA7CiAgICAgIHRoaXMuZm9yRWFjaCh0cmVlLCBmdW5jdGlvbiAoKSB7CiAgICAgICAgcmVzdWx0Kys7CiAgICAgIH0pOwogICAgICByZXR1cm4gcmVzdWx0OwogICAgfQogICAgLyoqCiAgICAgKiDpgY3ljobmoJHvvIzlubbliJvlu7rlkozljp/nu5PmnoTkuIDoh7TnmoTmlrDmoJHjgILmlrDmoJHnmoTnu5PngrnkuLrljp/moJHnu5PngrnosIPnlKjlh73mlbDlpITnkIblkI7nmoTlgLwKICAgICAqCiAgICAgKiAqKuazqOaEjyoq77yM5paw5qCR5LiN5Lya6Ieq5Yqo5Yib5bu65a2Q57uT54K577yM6ZyA6KaB5ZyobWFwRnVuY3Rpb27kuK3vvIzmiorov5Tlm57lgLzlkozlj4LmlbDkuK3nmoRuZXdDaGlsZHJlbui/m+ihjOWFs+iBlO+8jOS+i+WmgnJlc3VsdC5jaGlsZHJlbiA9IG5ld0NoaWxkcmVuCiAgICAgKgogICAgICogQHBhcmFtIHRyZWUKICAgICAqIEBwYXJhbSB7Kn0gbWFwRnVuY3Rpb24g5qC85byP5Li6KG5vZGUsIGluZGV4LCBvbGRQYXJlbnQsIG5ld0NoaWxkcmVuKT0+T2JqZWN0CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAibWFwIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBtYXAodHJlZSwgbWFwRnVuY3Rpb24pIHsKICAgICAgcmV0dXJuIHRoaXMuX21hcElubmVyKHRyZWUsIG1hcEZ1bmN0aW9uKTsKICAgIH0KICAgIC8qKgogICAgICoKICAgICAqIEBwYXJhbSB7Kn0gdHJlZQogICAgICogQHBhcmFtIHsqfSBtYXBGdW5jdGlvbgogICAgICogQHBhcmFtIHsqfSBwYXJlbnQKICAgICAqCiAgICAgKiBAcHJpdmF0ZQogICAgICovCgogIH0sIHsKICAgIGtleTogIl9tYXBJbm5lciIsCiAgICB2YWx1ZTogZnVuY3Rpb24gX21hcElubmVyKHRyZWUsIG1hcEZ1bmN0aW9uKSB7CiAgICAgIHZhciBwYXJlbnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IG51bGw7CgogICAgICAvL+W+queOr+agkee7k+eCue+8jOW5tuWFiOmAkuW9kuWtkOagke+8jOiOt+WPlueUqG1hcEZ1bmN0aW9u5Yib5bu655qE5paw5a2Q5qCRCiAgICAgIC8v5a2Q5qCR6YCS5b2S5a6M5oiQ5ZCO77yM55SobWFwRnVuY3Rpb27lr7nlvZPliY3nu5PngrnliJvlu7rmlrDnu5PngrnvvIzlubbmlL7liLDmlrDmoJHkuK0KICAgICAgLy/miorlrZDmoJHmlL7liLDmlrDnu5PngrnnmoTlrZDliJfooajkuK0KICAgICAgaWYgKHRyZWUpIHsKICAgICAgICB2YXIgcmVzdWx0ID0gW107CgogICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJlZS5sZW5ndGg7IGkrKykgewogICAgICAgICAgdmFyIF9ub2RlMiA9IHRyZWVbaV07CgogICAgICAgICAgdmFyIF9jaGlsZHJlbjQgPSB0aGlzLl9tYXBJbm5lcih0aGlzLmdldENoaWxkcmVuKF9ub2RlMiksIG1hcEZ1bmN0aW9uLCBfbm9kZTIpOwoKICAgICAgICAgIHZhciBuZXdOb2RlID0gbWFwRnVuY3Rpb24oX25vZGUyLCBpLCBwYXJlbnQsIF9jaGlsZHJlbjQpOwogICAgICAgICAgcmVzdWx0LnB1c2gobmV3Tm9kZSk7CiAgICAgICAgfQoKICAgICAgICByZXR1cm4gcmVzdWx0OwogICAgICB9CgogICAgICByZXR1cm4gbnVsbDsKICAgIH0KICAgIC8qKgogICAgICog5YaF6YOo55So5LqO6YCS5b2S5pCc57Si57uT54K56ZO+55qE5Ye95pWwCiAgICAgKiBAcGFyYW0gdHJlZSDmoJEKICAgICAqIEBwYXJhbSBlcXVhbEZ1bmN0aW9uIOWMuemFjeWHveaVsO+8jOagvOW8j+S4uihub2RlLCBpbmRleCwgcGFyZW50Tm9kZSk9PmJvb2wKICAgICAqIEBwYXJhbSBwYXJlbnQg54i257uT54K5CiAgICAgKgogICAgICogQHByaXZhdGUKICAgICAqCiAgICAgKiBAcmV0dXJuIHtBcnJheX0g5LuO5qC557uT54K55b2T56ym5ZCI5p2h5Lu255qE57uT54K555qE5pWw57uECiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiX3NlYXJjaENoYWluSW5uZXIiLAogICAgdmFsdWU6IGZ1bmN0aW9uIF9zZWFyY2hDaGFpbklubmVyKHRyZWUsIGVxdWFsRnVuY3Rpb24pIHsKICAgICAgdmFyIHBhcmVudCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogbnVsbDsKCiAgICAgIGlmICh0cmVlKSB7CiAgICAgICAgLy/lvqrnjq/moJHvvIzlpoLmnpzmnInnu5PngrnnrKblkIjmnaHku7bvvIzliJnmlL7liLDmlbDnu4TkuK3ov5Tlm54KICAgICAgICAvL+WmguaenOe7k+eCueS4jeespuWQiOadoeS7tu+8jOS9huaYr+acieWtkOe7k+eCue+8jOWImemAkuW9kuWtkOe7k+eCue+8jOWmguaenOS7juWtkOe7k+eCueS4reaJvuWIsOe7k+eCue+8jOaKiuW9k+WJjee7k+eCueaUvuWIsOWtkOe7k+aenOS4re+8jOS4gOi1t+i/lOWbngogICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJlZS5sZW5ndGg7IGkrKykgewogICAgICAgICAgdmFyIF9ub2RlMyA9IHRyZWVbaV07CgogICAgICAgICAgaWYgKGVxdWFsRnVuY3Rpb24oX25vZGUzLCBpLCBwYXJlbnQpKSB7CiAgICAgICAgICAgIHJldHVybiBbX25vZGUzXTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHZhciBfY2hpbGRyZW41ID0gdGhpcy5nZXRDaGlsZHJlbihfbm9kZTMpOwoKICAgICAgICAgICAgaWYgKF9jaGlsZHJlbjUpIHsKICAgICAgICAgICAgICB2YXIgY2hpbGRSZXN1bHQgPSB0aGlzLl9zZWFyY2hDaGFpbklubmVyKF9jaGlsZHJlbjUsIGVxdWFsRnVuY3Rpb24sIF9ub2RlMyk7CgogICAgICAgICAgICAgIGlmIChjaGlsZFJlc3VsdCkgewogICAgICAgICAgICAgICAgY2hpbGRSZXN1bHQudW5zaGlmdChfbm9kZTMpOwogICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkUmVzdWx0OwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQoKICAgICAgcmV0dXJuIG51bGw7CiAgICB9CiAgICAvKioKICAgICAqIOmBjeWOhuagkQogICAgICogQHBhcmFtIHRyZWUKICAgICAqIEBwYXJhbSBmb3JFYWNoRnVuY3Rpb24g6KaB5a+557uT54K56L+b6KGM5pON5L2c55qE5Ye95pWw77yM5qC85byP5Li6KG5vZGUsIGluZGV4LCBwYXJlbnROb2RlKT0+dm9pZAogICAgICogQHBhcmFtIHBhcmVudAogICAgICoKICAgICAqIEBwcml2YXRlCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiX2ZvckVhY2hJbm5lciIsCiAgICB2YWx1ZTogZnVuY3Rpb24gX2ZvckVhY2hJbm5lcih0cmVlLCBmb3JFYWNoRnVuY3Rpb24pIHsKICAgICAgdmFyIHBhcmVudCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogbnVsbDsKCiAgICAgIGlmICh0cmVlKSB7CiAgICAgICAgLy/pgY3ljobnu5PngrnvvIzlr7nnu5PngrnmiafooYzmk43kvZzvvIzlubbpgJLlvZLlrZDnu5PngrkKICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyZWUubGVuZ3RoOyBpKyspIHsKICAgICAgICAgIHZhciBfbm9kZTQgPSB0cmVlW2ldOwogICAgICAgICAgZm9yRWFjaEZ1bmN0aW9uKF9ub2RlNCwgaSwgcGFyZW50KTsKCiAgICAgICAgICB0aGlzLl9mb3JFYWNoSW5uZXIodGhpcy5nZXRDaGlsZHJlbihfbm9kZTQpLCBmb3JFYWNoRnVuY3Rpb24pOwogICAgICAgIH0KICAgICAgfQoKICAgICAgcmV0dXJuIG51bGw7CiAgICB9CiAgICAvKioKICAgICAqIOiOt+WPlue7k+eCueeahOWAvAogICAgICogQHBhcmFtIHsqfSBub2RlCiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiZ2V0Tm9kZURhdGEiLAogICAgdmFsdWU6IGZ1bmN0aW9uIGdldE5vZGVEYXRhKG5vZGUpIHsKICAgICAgaWYgKHRoaXMuZGF0YUdldHRlciBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7CiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YUdldHRlcihub2RlKTsKICAgICAgfSBlbHNlIHsKICAgICAgICByZXR1cm4gbm9kZVt0aGlzLmRhdGFHZXR0ZXJdOwogICAgICB9CiAgICB9CiAgICAvKioKICAgICAqIOiOt+WPlue7k+eCueeahOWtkOe7k+eCueWIl+ihqAogICAgICogQHBhcmFtIHsqfSBub2RlCiAgICAgKgogICAgICogQHJldHVybiB7QXJyYXl9CiAgICAgKi8KCiAgfSwgewogICAga2V5OiAiZ2V0Q2hpbGRyZW4iLAogICAgdmFsdWU6IGZ1bmN0aW9uIGdldENoaWxkcmVuKG5vZGUpIHsKICAgICAgaWYgKHRoaXMuY2hpbGRyZW5HZXR0ZXIgaW5zdGFuY2VvZiBGdW5jdGlvbikgewogICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuR2V0dGVyKG5vZGUpOwogICAgICB9IGVsc2UgewogICAgICAgIHJldHVybiBub2RlW3RoaXMuY2hpbGRyZW5HZXR0ZXJdOwogICAgICB9CiAgICB9CiAgfSwgewogICAga2V5OiAiX2NyZWF0ZUNoaWxkcmVuIiwKICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlQ2hpbGRyZW4obm9kZSwgY2hpbGRyZW4pIHsKICAgICAgaWYgKHRoaXMuY2hpbGRyZW5DcmVhdGVyIGluc3RhbmNlb2YgRnVuY3Rpb24pIHsKICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbkNyZWF0ZXIobm9kZSwgY2hpbGRyZW4pOwogICAgICB9IGVsc2UgewogICAgICAgIG5vZGVbdGhpcy5jaGlsZHJlbkNyZWF0ZXJdID0gY2hpbGRyZW4gfHwgW107CiAgICAgICAgcmV0dXJuIG5vZGVbdGhpcy5jaGlsZHJlbkNyZWF0ZXJdOwogICAgICB9CiAgICB9CiAgfSwgewogICAga2V5OiAiX19yZWFjdHN0YW5kaW5fX3JlZ2VuZXJhdGVCeUV2YWwiLAogICAgLy8gQHRzLWlnbm9yZQogICAgdmFsdWU6IGZ1bmN0aW9uIF9fcmVhY3RzdGFuZGluX19yZWdlbmVyYXRlQnlFdmFsKGtleSwgY29kZSkgewogICAgICAvLyBAdHMtaWdub3JlCiAgICAgIHRoaXNba2V5XSA9IGV2YWwoY29kZSk7CiAgICB9CiAgfV0pOwoKICByZXR1cm4gVHJlZUNvbnRyb2w7Cn0oKTsKCnZhciBfZGVmYXVsdCA9IFRyZWVDb250cm9sOwpleHBvcnQgZGVmYXVsdCBfZGVmYXVsdDsKCmlmICh0eXBlb2YgVHJlZUNvbnRyb2wgIT09ICd1bmRlZmluZWQnICYmIFRyZWVDb250cm9sICYmIFRyZWVDb250cm9sID09PSBPYmplY3QoVHJlZUNvbnRyb2wpICYmIE9iamVjdC5pc0V4dGVuc2libGUoVHJlZUNvbnRyb2wpKSB7CiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRyZWVDb250cm9sLCAnX19maWxlbWV0YScsIHsKICAgIGVudW1lcmFibGU6IHRydWUsCiAgICBjb25maWd1cmFibGU6IHRydWUsCiAgICB2YWx1ZTogewogICAgICBuYW1lOiAiVHJlZUNvbnRyb2wiLAogICAgICBmaWxlbmFtZTogInNyYy91dGlscy9UcmVlQ29udHJvbC50cyIKICAgIH0KICB9KTsKfQoKOwoKKGZ1bmN0aW9uICgpIHsKICB2YXIgcmVhY3RIb3RMb2FkZXIgPSB0eXBlb2YgcmVhY3RIb3RMb2FkZXJHbG9iYWwgIT09ICd1bmRlZmluZWQnID8gcmVhY3RIb3RMb2FkZXJHbG9iYWwuZGVmYXVsdCA6IHVuZGVmaW5lZDsKCiAgaWYgKCFyZWFjdEhvdExvYWRlcikgewogICAgcmV0dXJuOwogIH0KCiAgcmVhY3RIb3RMb2FkZXIucmVnaXN0ZXIoVHJlZUNvbnRyb2wsICJUcmVlQ29udHJvbCIsICIvVXNlcnMveHVqdW5qaWUvRG9jdW1lbnRzL2dpdC9wcm9qZWN0Q29tcG9uZW50L3NyYy91dGlscy9UcmVlQ29udHJvbC50cyIpOwogIHJlYWN0SG90TG9hZGVyLnJlZ2lzdGVyKF9kZWZhdWx0LCAiZGVmYXVsdCIsICIvVXNlcnMveHVqdW5qaWUvRG9jdW1lbnRzL2dpdC9wcm9qZWN0Q29tcG9uZW50L3NyYy91dGlscy9UcmVlQ29udHJvbC50cyIpOwp9KSgpOwoKOwoKKGZ1bmN0aW9uICgpIHsKICB2YXIgbGVhdmVNb2R1bGUgPSB0eXBlb2YgcmVhY3RIb3RMb2FkZXJHbG9iYWwgIT09ICd1bmRlZmluZWQnID8gcmVhY3RIb3RMb2FkZXJHbG9iYWwubGVhdmVNb2R1bGUgOiB1bmRlZmluZWQ7CiAgbGVhdmVNb2R1bGUgJiYgbGVhdmVNb2R1bGUobW9kdWxlKTsKfSkoKTs="},{"version":3,"sources":["/Users/xujunjie/Documents/git/projectComponent/src/utils/TreeControl.ts"],"names":["TreeControl","dataGetter","childrenGetter","childrenCreater","Error","tree","equal","_filterInner","parentNode","result","i","length","item","push","filterChildren","getChildren","_createChildren","list","equalParent","innerListTree","parent","children","equalFunction","chain","_searchChainInner","searchParent","child","index","node","search","realIndex","Math","max","min","_removeInner","splice","forEachFunction","_forEachInner","forEach","mapFunction","_mapInner","newNode","childResult","unshift","Function"],"mappings":"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","sourcesContent":["type equalFunctionType<T> = (node: T, index: number, parentNode: T | null) => boolean;\n\n/**\n * 一个通用的树结构操作器，对源数据的结构没有要求\n * @author yinhunfeixue\n * @email yinhunfeixue@163.com\n */\nclass TreeControl<T extends { [key: string]: any }> {\n  private dataGetter: string | ((item: T) => any);\n  private childrenGetter: string | ((item: T) => T[]);\n  private childrenCreater: string | ((item: T, children?: T[]) => T[]);\n\n  /**\n   * 创建树控制器实例\n   * @param {String|Function} dataGetter 获取结点值的方法，为字符串或(node)=>object的函数\n   * @param {String|Function} childrenGetter 获取结点子结点列表的方法，为字符串或(node)=>object的函数\n   */\n  constructor(\n    dataGetter: string | ((item: T) => any) = 'value',\n    childrenGetter: string | ((item: T) => any[]) = 'children',\n    childrenCreater: string | ((item: T, children?: T[]) => any[]) = 'children',\n  ) {\n    if (!dataGetter) {\n      throw new Error('dataGetter need value');\n    } else if (!childrenGetter) {\n      throw new Error('childrenGetter need value');\n    } else {\n      this.dataGetter = dataGetter;\n      this.childrenGetter = childrenGetter;\n      this.childrenCreater = childrenCreater;\n    }\n  }\n\n  /**\n   * 过滤树\n   * @param tree 树\n   * @param equal 是否匹配的方法，返回true，表示结果中包含此结点及基子结点\n   */\n  public filter(tree: T[], equal: equalFunctionType<T>): T[] {\n    return this._filterInner(tree, equal, null);\n  }\n\n  private _filterInner(tree: T[], equal: equalFunctionType<T>, parentNode: T | null): T[] {\n    if (!tree) {\n      return [];\n    }\n    const result: T[] = [];\n    // 循环tree\n    // 对于每一项，如果equal返回true，添加到结果列表中；否则，递归子列表，如果递归的子列表>=0，添加到结果列表\n    for (let i = 0; i < tree.length; i++) {\n      const item = { ...(tree[i] as any) };\n      if (equal(item, i, parentNode)) {\n        result.push(item);\n      } else {\n        const filterChildren = this._filterInner(this.getChildren(item), equal, item);\n        if (filterChildren && filterChildren.length > 0) {\n          result.push(item);\n          this._createChildren(item, filterChildren);\n        }\n      }\n    }\n    return result;\n  }\n\n  /**\n   * 一维数组转换成树结构\n   * @param list\n   */\n  public listToTree(list: T[], equalParent: (node: T, parentNode: T | null) => boolean): T[] {\n    return this.innerListTree(list, equalParent, null);\n  }\n\n  private innerListTree(\n    list: T[],\n    equalParent: (node: T, parentNode: T | null) => boolean,\n    parent: T | null,\n  ): T[] {\n    if (!list) {\n      return [];\n    }\n    // 循环list，针对每一项item：使用equalParent判断parent是否是item的父结点\n    // 如果是，则添加到结果列表；并以item为父结点，查找子列表\n    // 否则，不处理\n    const result: T[] = [];\n    for (let i = 0; i < list.length; i++) {\n      const item = list[i];\n      if (equalParent(item, parent)) {\n        result.push(item);\n        const children = this.innerListTree(list, equalParent, item);\n        if (children && children.length) {\n          this._createChildren(item, children);\n        }\n      }\n    }\n    return result;\n  }\n\n  /**\n   * 搜索满足指定条件的第一个结点\n   * @param 树结点的数据\n   * @param 匹配函数\n   */\n  search(tree: T[], equalFunction: equalFunctionType<T>) {\n    let chain = this._searchChainInner(tree, equalFunction);\n    return chain && chain.length ? chain[chain.length - 1] : null;\n  }\n\n  /**\n   * 搜索满足指定条件的第一个结点的父结点\n   * @param tree 树\n   * @param equalFunction 匹配函数，格式为(node, index, parentNode)=>bool\n   */\n  searchParent(tree: T[], equalFunction: equalFunctionType<T>) {\n    let chain = this._searchChainInner(tree, equalFunction);\n    if (chain && chain.length >= 2) {\n      return chain[chain.length - 2];\n    }\n    return null;\n  }\n\n  /**\n   * 获取满足指定条件的第一个结点在父结点子列表中的位置，如果无父结点，或结点不存在，返回-1\n   * @param tree 树\n   * @param equalFunction 匹配函数，格式为(node, index, parentNode)=>bool\n   *\n   * @return {Number} 指定条件的结点所在的位置\n   */\n  getIndex(tree: T[], equalFunction: equalFunctionType<T>) {\n    let parent = this.searchParent(tree, equalFunction);\n    if (parent) {\n      let children = this.getChildren(parent);\n      for (let i = 0; i < children.length; i++) {\n        if (equalFunction(children[i], i, parent)) {\n          return i;\n        }\n      }\n    }\n    return -1;\n  }\n\n  addAt(tree: T[], equalFunction: equalFunctionType<T>, child: T, index = -1) {\n    let node = this.search(tree, equalFunction);\n    if (node) {\n      let children = this.getChildren(node);\n      if (!children) {\n        children = this._createChildren(node);\n      }\n\n      if (children) {\n        let realIndex = Math.max(0, Math.min(children.length, index));\n        children[realIndex] = child;\n      }\n    }\n  }\n\n  remove(tree: T[], equalFunction: equalFunctionType<T>) {\n    this._removeInner(tree, equalFunction);\n  }\n\n  /**\n   *\n   * @param tree\n   * @param equalFunction\n   */\n  _removeInner(tree: T[], equalFunction: equalFunctionType<T>, parent: T | null = null) {\n    if (tree) {\n      //遍历结点\n      for (let i = 0; i < tree.length; i++) {\n        let node = tree[i];\n        //如果当前结点符合被删除的条件，则删除；不符合，则递归子结点\n        if (equalFunction(node, i, parent)) {\n          tree.splice(i, 1);\n          i--;\n        } else {\n          this._removeInner(this.getChildren(node), equalFunction, node);\n        }\n      }\n    }\n  }\n\n  /**\n   * 搜索满足条件的第一个结点，并返回从一级结点到指定结点的数组，第一项是一级结点，最后一项是符合条件的结点\n   * @param tree 树\n   * @param equalFunction 匹配函数\n   */\n  searchChain(tree: T[], equalFunction: equalFunctionType<T>) {\n    return this._searchChainInner(tree, equalFunction);\n  }\n\n  /**\n   * 遍历树结点，并对每个结点执行回调函数\n   * @param {Array} tree 树\n   * @param {Function} forEachFunction 回调函数\n   */\n  forEach(tree: T[], forEachFunction: (node: T, index: number, parentNode: T | null) => void) {\n    this._forEachInner(tree, forEachFunction);\n  }\n\n  /**\n   * 查找所有符合条件的结点，并返回符合条件结点的一维数组\n   * @param tree 树\n   * @param equalFunction 匹配函数\n   */\n  find(tree: T[], equalFunction: equalFunctionType<T>) {\n    let result: T[] = [];\n    this.forEach(tree, (node, i, parent) => {\n      if (equalFunction(node, i, parent)) {\n        result.push(node);\n      }\n    });\n    return result;\n  }\n\n  /**\n   * 计算树的结点总数\n   * @param tree 树\n   */\n  count(tree: T[]) {\n    let result = 0;\n    this.forEach(tree, () => {\n      result++;\n    });\n    return result;\n  }\n\n  /**\n   * 遍历树，并创建和原结构一致的新树。新树的结点为原树结点调用函数处理后的值\n   *\n   * **注意**，新树不会自动创建子结点，需要在mapFunction中，把返回值和参数中的newChildren进行关联，例如result.children = newChildren\n   *\n   * @param tree\n   * @param {*} mapFunction 格式为(node, index, oldParent, newChildren)=>Object\n   */\n  map<W>(\n    tree: T[],\n    mapFunction: (node: T, index: number, oldParent: T | null, newChildren: W[] | null) => W,\n  ) {\n    return this._mapInner(tree, mapFunction);\n  }\n\n  /**\n   *\n   * @param {*} tree\n   * @param {*} mapFunction\n   * @param {*} parent\n   *\n   * @private\n   */\n  _mapInner<W>(\n    tree: T[],\n    mapFunction: (node: T, index: number, oldParent: T | null, newChildren: W[] | null) => W,\n    parent: T | null = null,\n  ) {\n    //循环树结点，并先递归子树，获取用mapFunction创建的新子树\n    //子树递归完成后，用mapFunction对当前结点创建新结点，并放到新树中\n    //把子树放到新结点的子列表中\n    if (tree) {\n      let result = [];\n      for (let i = 0; i < tree.length; i++) {\n        let node = tree[i];\n        let children = this._mapInner(this.getChildren(node), mapFunction, node);\n        let newNode = mapFunction(node, i, parent, children);\n        result.push(newNode);\n      }\n      return result;\n    }\n    return null;\n  }\n\n  /**\n   * 内部用于递归搜索结点链的函数\n   * @param tree 树\n   * @param equalFunction 匹配函数，格式为(node, index, parentNode)=>bool\n   * @param parent 父结点\n   *\n   * @private\n   *\n   * @return {Array} 从根结点当符合条件的结点的数组\n   */\n  private _searchChainInner(\n    tree: T[],\n    equalFunction: equalFunctionType<T>,\n    parent: T | null = null,\n  ): T[] | null {\n    if (tree) {\n      //循环树，如果有结点符合条件，则放到数组中返回\n      //如果结点不符合条件，但是有子结点，则递归子结点，如果从子结点中找到结点，把当前结点放到子结果中，一起返回\n      for (let i = 0; i < tree.length; i++) {\n        let node = tree[i];\n        if (equalFunction(node, i, parent)) {\n          return [node];\n        } else {\n          let children = this.getChildren(node);\n          if (children) {\n            let childResult = this._searchChainInner(children, equalFunction, node);\n            if (childResult) {\n              childResult.unshift(node);\n              return childResult;\n            }\n          }\n        }\n      }\n    }\n    return null;\n  }\n\n  /**\n   * 遍历树\n   * @param tree\n   * @param forEachFunction 要对结点进行操作的函数，格式为(node, index, parentNode)=>void\n   * @param parent\n   *\n   * @private\n   */\n  private _forEachInner(\n    tree: T[],\n    forEachFunction: (node: T, index: number, parentNode: T | null) => void,\n    parent = null,\n  ) {\n    if (tree) {\n      //遍历结点，对结点执行操作，并递归子结点\n      for (let i = 0; i < tree.length; i++) {\n        let node = tree[i];\n        forEachFunction(node, i, parent);\n        this._forEachInner(this.getChildren(node), forEachFunction);\n      }\n    }\n    return null;\n  }\n\n  /**\n   * 获取结点的值\n   * @param {*} node\n   */\n  getNodeData(node: T) {\n    if (this.dataGetter instanceof Function) {\n      return this.dataGetter(node);\n    } else {\n      return node[this.dataGetter];\n    }\n  }\n\n  /**\n   * 获取结点的子结点列表\n   * @param {*} node\n   *\n   * @return {Array}\n   */\n  getChildren(node: T) {\n    if (this.childrenGetter instanceof Function) {\n      return this.childrenGetter(node);\n    } else {\n      return node[this.childrenGetter];\n    }\n  }\n\n  _createChildren(node: T, children?: T[]) {\n    if (this.childrenCreater instanceof Function) {\n      return this.childrenCreater(node, children);\n    } else {\n      (node as any)[this.childrenCreater] = children || [];\n      return node[this.childrenCreater];\n    }\n  }\n}\n\nexport default TreeControl;\n"]}]}