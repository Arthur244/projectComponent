{"remainingRequest":"/Users/xujunjie/Documents/git/projectComponent/node_modules/thread-loader/dist/cjs.js??ref--11-1!/Users/xujunjie/Documents/git/projectComponent/node_modules/docz-core/node_modules/babel-loader/lib/index.js??ref--11-2!/Users/xujunjie/Documents/git/projectComponent/node_modules/source-map-loader/index.js!/Users/xujunjie/Documents/git/projectComponent/src/utils/TreeControl.ts","dependencies":[{"path":"/Users/xujunjie/Documents/git/projectComponent/src/utils/TreeControl.ts","mtime":1608989725151},{"path":"/Users/xujunjie/Documents/git/projectComponent/node_modules/cache-loader/dist/cjs.js","mtime":1609062632110},{"path":"/Users/xujunjie/Documents/git/projectComponent/node_modules/thread-loader/dist/cjs.js","mtime":1609062632658},{"path":"/Users/xujunjie/Documents/git/projectComponent/node_modules/docz-core/node_modules/babel-loader/lib/index.js","mtime":1609062558293},{"path":"/Users/xujunjie/Documents/git/projectComponent/node_modules/source-map-loader/index.js","mtime":1609062632650}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0IF9vYmplY3RTcHJlYWQgZnJvbSIvVXNlcnMveHVqdW5qaWUvRG9jdW1lbnRzL2dpdC9wcm9qZWN0Q29tcG9uZW50L25vZGVfbW9kdWxlcy9iYWJlbC1wcmVzZXQtcmVhY3QtYXBwL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9vYmplY3RTcHJlYWQyIjtpbXBvcnQgX2NsYXNzQ2FsbENoZWNrIGZyb20iL1VzZXJzL3h1anVuamllL0RvY3VtZW50cy9naXQvcHJvamVjdENvbXBvbmVudC9ub2RlX21vZHVsZXMvYmFiZWwtcHJlc2V0LXJlYWN0LWFwcC9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY2xhc3NDYWxsQ2hlY2siO2ltcG9ydCBfY3JlYXRlQ2xhc3MgZnJvbSIvVXNlcnMveHVqdW5qaWUvRG9jdW1lbnRzL2dpdC9wcm9qZWN0Q29tcG9uZW50L25vZGVfbW9kdWxlcy9iYWJlbC1wcmVzZXQtcmVhY3QtYXBwL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jcmVhdGVDbGFzcyI7LyoqCiAqIOS4gOS4qumAmueUqOeahOagkee7k+aehOaTjeS9nOWZqO+8jOWvuea6kOaVsOaNrueahOe7k+aehOayoeacieimgeaxggogKiBAYXV0aG9yIHlpbmh1bmZlaXh1ZQogKiBAZW1haWwgeWluaHVuZmVpeHVlQDE2My5jb20KICovdmFyIFRyZWVDb250cm9sPS8qI19fUFVSRV9fKi9mdW5jdGlvbigpey8qKgogICAqIOWIm+W7uuagkeaOp+WItuWZqOWunuS+iwogICAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBkYXRhR2V0dGVyIOiOt+WPlue7k+eCueWAvOeahOaWueazle+8jOS4uuWtl+espuS4suaIlihub2RlKT0+b2JqZWN055qE5Ye95pWwCiAgICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IGNoaWxkcmVuR2V0dGVyIOiOt+WPlue7k+eCueWtkOe7k+eCueWIl+ihqOeahOaWueazle+8jOS4uuWtl+espuS4suaIlihub2RlKT0+b2JqZWN055qE5Ye95pWwCiAgICovZnVuY3Rpb24gVHJlZUNvbnRyb2woKXt2YXIgZGF0YUdldHRlcj1hcmd1bWVudHMubGVuZ3RoPjAmJmFyZ3VtZW50c1swXSE9PXVuZGVmaW5lZD9hcmd1bWVudHNbMF06J3ZhbHVlJzt2YXIgY2hpbGRyZW5HZXR0ZXI9YXJndW1lbnRzLmxlbmd0aD4xJiZhcmd1bWVudHNbMV0hPT11bmRlZmluZWQ/YXJndW1lbnRzWzFdOidjaGlsZHJlbic7dmFyIGNoaWxkcmVuQ3JlYXRlcj1hcmd1bWVudHMubGVuZ3RoPjImJmFyZ3VtZW50c1syXSE9PXVuZGVmaW5lZD9hcmd1bWVudHNbMl06J2NoaWxkcmVuJztfY2xhc3NDYWxsQ2hlY2sodGhpcyxUcmVlQ29udHJvbCk7dGhpcy5kYXRhR2V0dGVyPXZvaWQgMDt0aGlzLmNoaWxkcmVuR2V0dGVyPXZvaWQgMDt0aGlzLmNoaWxkcmVuQ3JlYXRlcj12b2lkIDA7aWYoIWRhdGFHZXR0ZXIpe3Rocm93IG5ldyBFcnJvcignZGF0YUdldHRlciBuZWVkIHZhbHVlJyk7fWVsc2UgaWYoIWNoaWxkcmVuR2V0dGVyKXt0aHJvdyBuZXcgRXJyb3IoJ2NoaWxkcmVuR2V0dGVyIG5lZWQgdmFsdWUnKTt9ZWxzZXt0aGlzLmRhdGFHZXR0ZXI9ZGF0YUdldHRlcjt0aGlzLmNoaWxkcmVuR2V0dGVyPWNoaWxkcmVuR2V0dGVyO3RoaXMuY2hpbGRyZW5DcmVhdGVyPWNoaWxkcmVuQ3JlYXRlcjt9fS8qKgogICAqIOi/h+a7pOagkQogICAqIEBwYXJhbSB0cmVlIOagkQogICAqIEBwYXJhbSBlcXVhbCDmmK/lkKbljLnphY3nmoTmlrnms5XvvIzov5Tlm550cnVl77yM6KGo56S657uT5p6c5Lit5YyF5ZCr5q2k57uT54K55Y+K5Z+65a2Q57uT54K5CiAgICovX2NyZWF0ZUNsYXNzKFRyZWVDb250cm9sLFt7a2V5OiJmaWx0ZXIiLHZhbHVlOmZ1bmN0aW9uIGZpbHRlcih0cmVlLGVxdWFsKXtyZXR1cm4gdGhpcy5fZmlsdGVySW5uZXIodHJlZSxlcXVhbCxudWxsKTt9fSx7a2V5OiJfZmlsdGVySW5uZXIiLHZhbHVlOmZ1bmN0aW9uIF9maWx0ZXJJbm5lcih0cmVlLGVxdWFsLHBhcmVudE5vZGUpe2lmKCF0cmVlKXtyZXR1cm5bXTt9dmFyIHJlc3VsdD1bXTsvLyDlvqrnjq90cmVlCi8vIOWvueS6juavj+S4gOmhue+8jOWmguaenGVxdWFs6L+U5ZuedHJ1Ze+8jOa3u+WKoOWIsOe7k+aenOWIl+ihqOS4re+8m+WQpuWIme+8jOmAkuW9kuWtkOWIl+ihqO+8jOWmguaenOmAkuW9kueahOWtkOWIl+ihqD49MO+8jOa3u+WKoOWIsOe7k+aenOWIl+ihqApmb3IodmFyIGk9MDtpPHRyZWUubGVuZ3RoO2krKyl7dmFyIF9pdGVtPV9vYmplY3RTcHJlYWQoe30sdHJlZVtpXSk7aWYoZXF1YWwoX2l0ZW0saSxwYXJlbnROb2RlKSl7cmVzdWx0LnB1c2goX2l0ZW0pO31lbHNle3ZhciBmaWx0ZXJDaGlsZHJlbj10aGlzLl9maWx0ZXJJbm5lcih0aGlzLmdldENoaWxkcmVuKF9pdGVtKSxlcXVhbCxfaXRlbSk7aWYoZmlsdGVyQ2hpbGRyZW4mJmZpbHRlckNoaWxkcmVuLmxlbmd0aD4wKXtyZXN1bHQucHVzaChfaXRlbSk7dGhpcy5fY3JlYXRlQ2hpbGRyZW4oX2l0ZW0sZmlsdGVyQ2hpbGRyZW4pO319fXJldHVybiByZXN1bHQ7fS8qKgogICAqIOS4gOe7tOaVsOe7hOi9rOaNouaIkOagkee7k+aehAogICAqIEBwYXJhbSBsaXN0CiAgICovfSx7a2V5OiJsaXN0VG9UcmVlIix2YWx1ZTpmdW5jdGlvbiBsaXN0VG9UcmVlKGxpc3QsZXF1YWxQYXJlbnQpe3JldHVybiB0aGlzLmlubmVyTGlzdFRyZWUobGlzdCxlcXVhbFBhcmVudCxudWxsKTt9fSx7a2V5OiJpbm5lckxpc3RUcmVlIix2YWx1ZTpmdW5jdGlvbiBpbm5lckxpc3RUcmVlKGxpc3QsZXF1YWxQYXJlbnQscGFyZW50KXtpZighbGlzdCl7cmV0dXJuW107fS8vIOW+queOr2xpc3TvvIzpkojlr7nmr4/kuIDpoblpdGVt77ya5L2/55SoZXF1YWxQYXJlbnTliKTmlq1wYXJlbnTmmK/lkKbmmK9pdGVt55qE54i257uT54K5Ci8vIOWmguaenOaYr++8jOWImea3u+WKoOWIsOe7k+aenOWIl+ihqO+8m+W5tuS7pWl0ZW3kuLrniLbnu5PngrnvvIzmn6Xmib7lrZDliJfooagKLy8g5ZCm5YiZ77yM5LiN5aSE55CGCnZhciByZXN1bHQ9W107Zm9yKHZhciBpPTA7aTxsaXN0Lmxlbmd0aDtpKyspe3ZhciBfaXRlbTI9bGlzdFtpXTtpZihlcXVhbFBhcmVudChfaXRlbTIscGFyZW50KSl7cmVzdWx0LnB1c2goX2l0ZW0yKTt2YXIgX2NoaWxkcmVuPXRoaXMuaW5uZXJMaXN0VHJlZShsaXN0LGVxdWFsUGFyZW50LF9pdGVtMik7aWYoX2NoaWxkcmVuJiZfY2hpbGRyZW4ubGVuZ3RoKXt0aGlzLl9jcmVhdGVDaGlsZHJlbihfaXRlbTIsX2NoaWxkcmVuKTt9fX1yZXR1cm4gcmVzdWx0O30vKioKICAgKiDmkJzntKLmu6HotrPmjIflrprmnaHku7bnmoTnrKzkuIDkuKrnu5PngrkKICAgKiBAcGFyYW0g5qCR57uT54K555qE5pWw5o2uCiAgICogQHBhcmFtIOWMuemFjeWHveaVsAogICAqL30se2tleToic2VhcmNoIix2YWx1ZTpmdW5jdGlvbiBzZWFyY2godHJlZSxlcXVhbEZ1bmN0aW9uKXt2YXIgY2hhaW49dGhpcy5fc2VhcmNoQ2hhaW5Jbm5lcih0cmVlLGVxdWFsRnVuY3Rpb24pO3JldHVybiBjaGFpbiYmY2hhaW4ubGVuZ3RoP2NoYWluW2NoYWluLmxlbmd0aC0xXTpudWxsO30vKioKICAgKiDmkJzntKLmu6HotrPmjIflrprmnaHku7bnmoTnrKzkuIDkuKrnu5PngrnnmoTniLbnu5PngrkKICAgKiBAcGFyYW0gdHJlZSDmoJEKICAgKiBAcGFyYW0gZXF1YWxGdW5jdGlvbiDljLnphY3lh73mlbDvvIzmoLzlvI/kuLoobm9kZSwgaW5kZXgsIHBhcmVudE5vZGUpPT5ib29sCiAgICovfSx7a2V5OiJzZWFyY2hQYXJlbnQiLHZhbHVlOmZ1bmN0aW9uIHNlYXJjaFBhcmVudCh0cmVlLGVxdWFsRnVuY3Rpb24pe3ZhciBjaGFpbj10aGlzLl9zZWFyY2hDaGFpbklubmVyKHRyZWUsZXF1YWxGdW5jdGlvbik7aWYoY2hhaW4mJmNoYWluLmxlbmd0aD49Mil7cmV0dXJuIGNoYWluW2NoYWluLmxlbmd0aC0yXTt9cmV0dXJuIG51bGw7fS8qKgogICAqIOiOt+WPlua7oei2s+aMh+WumuadoeS7tueahOesrOS4gOS4que7k+eCueWcqOeItue7k+eCueWtkOWIl+ihqOS4reeahOS9jee9ru+8jOWmguaenOaXoOeItue7k+eCue+8jOaIlue7k+eCueS4jeWtmOWcqO+8jOi/lOWbni0xCiAgICogQHBhcmFtIHRyZWUg5qCRCiAgICogQHBhcmFtIGVxdWFsRnVuY3Rpb24g5Yy56YWN5Ye95pWw77yM5qC85byP5Li6KG5vZGUsIGluZGV4LCBwYXJlbnROb2RlKT0+Ym9vbAogICAqCiAgICogQHJldHVybiB7TnVtYmVyfSDmjIflrprmnaHku7bnmoTnu5PngrnmiYDlnKjnmoTkvY3nva4KICAgKi99LHtrZXk6ImdldEluZGV4Iix2YWx1ZTpmdW5jdGlvbiBnZXRJbmRleCh0cmVlLGVxdWFsRnVuY3Rpb24pe3ZhciBwYXJlbnQ9dGhpcy5zZWFyY2hQYXJlbnQodHJlZSxlcXVhbEZ1bmN0aW9uKTtpZihwYXJlbnQpe3ZhciBfY2hpbGRyZW4yPXRoaXMuZ2V0Q2hpbGRyZW4ocGFyZW50KTtmb3IodmFyIGk9MDtpPF9jaGlsZHJlbjIubGVuZ3RoO2krKyl7aWYoZXF1YWxGdW5jdGlvbihfY2hpbGRyZW4yW2ldLGkscGFyZW50KSl7cmV0dXJuIGk7fX19cmV0dXJuLTE7fX0se2tleToiYWRkQXQiLHZhbHVlOmZ1bmN0aW9uIGFkZEF0KHRyZWUsZXF1YWxGdW5jdGlvbixjaGlsZCl7dmFyIGluZGV4PWFyZ3VtZW50cy5sZW5ndGg+MyYmYXJndW1lbnRzWzNdIT09dW5kZWZpbmVkP2FyZ3VtZW50c1szXTotMTt2YXIgbm9kZT10aGlzLnNlYXJjaCh0cmVlLGVxdWFsRnVuY3Rpb24pO2lmKG5vZGUpe3ZhciBfY2hpbGRyZW4zPXRoaXMuZ2V0Q2hpbGRyZW4obm9kZSk7aWYoIV9jaGlsZHJlbjMpe19jaGlsZHJlbjM9dGhpcy5fY3JlYXRlQ2hpbGRyZW4obm9kZSk7fWlmKF9jaGlsZHJlbjMpe3ZhciByZWFsSW5kZXg9TWF0aC5tYXgoMCxNYXRoLm1pbihfY2hpbGRyZW4zLmxlbmd0aCxpbmRleCkpO19jaGlsZHJlbjNbcmVhbEluZGV4XT1jaGlsZDt9fX19LHtrZXk6InJlbW92ZSIsdmFsdWU6ZnVuY3Rpb24gcmVtb3ZlKHRyZWUsZXF1YWxGdW5jdGlvbil7dGhpcy5fcmVtb3ZlSW5uZXIodHJlZSxlcXVhbEZ1bmN0aW9uKTt9LyoqCiAgICoKICAgKiBAcGFyYW0gdHJlZQogICAqIEBwYXJhbSBlcXVhbEZ1bmN0aW9uCiAgICovfSx7a2V5OiJfcmVtb3ZlSW5uZXIiLHZhbHVlOmZ1bmN0aW9uIF9yZW1vdmVJbm5lcih0cmVlLGVxdWFsRnVuY3Rpb24pe3ZhciBwYXJlbnQ9YXJndW1lbnRzLmxlbmd0aD4yJiZhcmd1bWVudHNbMl0hPT11bmRlZmluZWQ/YXJndW1lbnRzWzJdOm51bGw7aWYodHJlZSl7Ly/pgY3ljobnu5PngrkKZm9yKHZhciBpPTA7aTx0cmVlLmxlbmd0aDtpKyspe3ZhciBfbm9kZT10cmVlW2ldOy8v5aaC5p6c5b2T5YmN57uT54K556ym5ZCI6KKr5Yig6Zmk55qE5p2h5Lu277yM5YiZ5Yig6Zmk77yb5LiN56ym5ZCI77yM5YiZ6YCS5b2S5a2Q57uT54K5CmlmKGVxdWFsRnVuY3Rpb24oX25vZGUsaSxwYXJlbnQpKXt0cmVlLnNwbGljZShpLDEpO2ktLTt9ZWxzZXt0aGlzLl9yZW1vdmVJbm5lcih0aGlzLmdldENoaWxkcmVuKF9ub2RlKSxlcXVhbEZ1bmN0aW9uLF9ub2RlKTt9fX19LyoqCiAgICog5pCc57Si5ruh6Laz5p2h5Lu255qE56ys5LiA5Liq57uT54K577yM5bm26L+U5Zue5LuO5LiA57qn57uT54K55Yiw5oyH5a6a57uT54K555qE5pWw57uE77yM56ys5LiA6aG55piv5LiA57qn57uT54K577yM5pyA5ZCO5LiA6aG55piv56ym5ZCI5p2h5Lu255qE57uT54K5CiAgICogQHBhcmFtIHRyZWUg5qCRCiAgICogQHBhcmFtIGVxdWFsRnVuY3Rpb24g5Yy56YWN5Ye95pWwCiAgICovfSx7a2V5OiJzZWFyY2hDaGFpbiIsdmFsdWU6ZnVuY3Rpb24gc2VhcmNoQ2hhaW4odHJlZSxlcXVhbEZ1bmN0aW9uKXtyZXR1cm4gdGhpcy5fc2VhcmNoQ2hhaW5Jbm5lcih0cmVlLGVxdWFsRnVuY3Rpb24pO30vKioKICAgKiDpgY3ljobmoJHnu5PngrnvvIzlubblr7nmr4/kuKrnu5PngrnmiafooYzlm57osIPlh73mlbAKICAgKiBAcGFyYW0ge0FycmF5fSB0cmVlIOagkQogICAqIEBwYXJhbSB7RnVuY3Rpb259IGZvckVhY2hGdW5jdGlvbiDlm57osIPlh73mlbAKICAgKi99LHtrZXk6ImZvckVhY2giLHZhbHVlOmZ1bmN0aW9uIGZvckVhY2godHJlZSxmb3JFYWNoRnVuY3Rpb24pe3RoaXMuX2ZvckVhY2hJbm5lcih0cmVlLGZvckVhY2hGdW5jdGlvbik7fS8qKgogICAqIOafpeaJvuaJgOacieespuWQiOadoeS7tueahOe7k+eCue+8jOW5tui/lOWbnuespuWQiOadoeS7tue7k+eCueeahOS4gOe7tOaVsOe7hAogICAqIEBwYXJhbSB0cmVlIOagkQogICAqIEBwYXJhbSBlcXVhbEZ1bmN0aW9uIOWMuemFjeWHveaVsAogICAqL30se2tleToiZmluZCIsdmFsdWU6ZnVuY3Rpb24gZmluZCh0cmVlLGVxdWFsRnVuY3Rpb24pe3ZhciByZXN1bHQ9W107dGhpcy5mb3JFYWNoKHRyZWUsZnVuY3Rpb24obm9kZSxpLHBhcmVudCl7aWYoZXF1YWxGdW5jdGlvbihub2RlLGkscGFyZW50KSl7cmVzdWx0LnB1c2gobm9kZSk7fX0pO3JldHVybiByZXN1bHQ7fS8qKgogICAqIOiuoeeul+agkeeahOe7k+eCueaAu+aVsAogICAqIEBwYXJhbSB0cmVlIOagkQogICAqL30se2tleToiY291bnQiLHZhbHVlOmZ1bmN0aW9uIGNvdW50KHRyZWUpe3ZhciByZXN1bHQ9MDt0aGlzLmZvckVhY2godHJlZSxmdW5jdGlvbigpe3Jlc3VsdCsrO30pO3JldHVybiByZXN1bHQ7fS8qKgogICAqIOmBjeWOhuagke+8jOW5tuWIm+W7uuWSjOWOn+e7k+aehOS4gOiHtOeahOaWsOagkeOAguaWsOagkeeahOe7k+eCueS4uuWOn+agkee7k+eCueiwg+eUqOWHveaVsOWkhOeQhuWQjueahOWAvAogICAqCiAgICogKirms6jmhI8qKu+8jOaWsOagkeS4jeS8muiHquWKqOWIm+W7uuWtkOe7k+eCue+8jOmcgOimgeWcqG1hcEZ1bmN0aW9u5Lit77yM5oqK6L+U5Zue5YC85ZKM5Y+C5pWw5Lit55qEbmV3Q2hpbGRyZW7ov5vooYzlhbPogZTvvIzkvovlpoJyZXN1bHQuY2hpbGRyZW4gPSBuZXdDaGlsZHJlbgogICAqCiAgICogQHBhcmFtIHRyZWUKICAgKiBAcGFyYW0geyp9IG1hcEZ1bmN0aW9uIOagvOW8j+S4uihub2RlLCBpbmRleCwgb2xkUGFyZW50LCBuZXdDaGlsZHJlbik9Pk9iamVjdAogICAqL30se2tleToibWFwIix2YWx1ZTpmdW5jdGlvbiBtYXAodHJlZSxtYXBGdW5jdGlvbil7cmV0dXJuIHRoaXMuX21hcElubmVyKHRyZWUsbWFwRnVuY3Rpb24pO30vKioKICAgKgogICAqIEBwYXJhbSB7Kn0gdHJlZQogICAqIEBwYXJhbSB7Kn0gbWFwRnVuY3Rpb24KICAgKiBAcGFyYW0geyp9IHBhcmVudAogICAqCiAgICogQHByaXZhdGUKICAgKi99LHtrZXk6Il9tYXBJbm5lciIsdmFsdWU6ZnVuY3Rpb24gX21hcElubmVyKHRyZWUsbWFwRnVuY3Rpb24pe3ZhciBwYXJlbnQ9YXJndW1lbnRzLmxlbmd0aD4yJiZhcmd1bWVudHNbMl0hPT11bmRlZmluZWQ/YXJndW1lbnRzWzJdOm51bGw7Ly/lvqrnjq/moJHnu5PngrnvvIzlubblhYjpgJLlvZLlrZDmoJHvvIzojrflj5bnlKhtYXBGdW5jdGlvbuWIm+W7uueahOaWsOWtkOagkQovL+WtkOagkemAkuW9kuWujOaIkOWQju+8jOeUqG1hcEZ1bmN0aW9u5a+55b2T5YmN57uT54K55Yib5bu65paw57uT54K577yM5bm25pS+5Yiw5paw5qCR5LitCi8v5oqK5a2Q5qCR5pS+5Yiw5paw57uT54K555qE5a2Q5YiX6KGo5LitCmlmKHRyZWUpe3ZhciByZXN1bHQ9W107Zm9yKHZhciBpPTA7aTx0cmVlLmxlbmd0aDtpKyspe3ZhciBfbm9kZTI9dHJlZVtpXTt2YXIgX2NoaWxkcmVuND10aGlzLl9tYXBJbm5lcih0aGlzLmdldENoaWxkcmVuKF9ub2RlMiksbWFwRnVuY3Rpb24sX25vZGUyKTt2YXIgbmV3Tm9kZT1tYXBGdW5jdGlvbihfbm9kZTIsaSxwYXJlbnQsX2NoaWxkcmVuNCk7cmVzdWx0LnB1c2gobmV3Tm9kZSk7fXJldHVybiByZXN1bHQ7fXJldHVybiBudWxsO30vKioKICAgKiDlhoXpg6jnlKjkuo7pgJLlvZLmkJzntKLnu5Pngrnpk77nmoTlh73mlbAKICAgKiBAcGFyYW0gdHJlZSDmoJEKICAgKiBAcGFyYW0gZXF1YWxGdW5jdGlvbiDljLnphY3lh73mlbDvvIzmoLzlvI/kuLoobm9kZSwgaW5kZXgsIHBhcmVudE5vZGUpPT5ib29sCiAgICogQHBhcmFtIHBhcmVudCDniLbnu5PngrkKICAgKgogICAqIEBwcml2YXRlCiAgICoKICAgKiBAcmV0dXJuIHtBcnJheX0g5LuO5qC557uT54K55b2T56ym5ZCI5p2h5Lu255qE57uT54K555qE5pWw57uECiAgICovfSx7a2V5OiJfc2VhcmNoQ2hhaW5Jbm5lciIsdmFsdWU6ZnVuY3Rpb24gX3NlYXJjaENoYWluSW5uZXIodHJlZSxlcXVhbEZ1bmN0aW9uKXt2YXIgcGFyZW50PWFyZ3VtZW50cy5sZW5ndGg+MiYmYXJndW1lbnRzWzJdIT09dW5kZWZpbmVkP2FyZ3VtZW50c1syXTpudWxsO2lmKHRyZWUpey8v5b6q546v5qCR77yM5aaC5p6c5pyJ57uT54K556ym5ZCI5p2h5Lu277yM5YiZ5pS+5Yiw5pWw57uE5Lit6L+U5ZueCi8v5aaC5p6c57uT54K55LiN56ym5ZCI5p2h5Lu277yM5L2G5piv5pyJ5a2Q57uT54K577yM5YiZ6YCS5b2S5a2Q57uT54K577yM5aaC5p6c5LuO5a2Q57uT54K55Lit5om+5Yiw57uT54K577yM5oqK5b2T5YmN57uT54K55pS+5Yiw5a2Q57uT5p6c5Lit77yM5LiA6LW36L+U5ZueCmZvcih2YXIgaT0wO2k8dHJlZS5sZW5ndGg7aSsrKXt2YXIgX25vZGUzPXRyZWVbaV07aWYoZXF1YWxGdW5jdGlvbihfbm9kZTMsaSxwYXJlbnQpKXtyZXR1cm5bX25vZGUzXTt9ZWxzZXt2YXIgX2NoaWxkcmVuNT10aGlzLmdldENoaWxkcmVuKF9ub2RlMyk7aWYoX2NoaWxkcmVuNSl7dmFyIGNoaWxkUmVzdWx0PXRoaXMuX3NlYXJjaENoYWluSW5uZXIoX2NoaWxkcmVuNSxlcXVhbEZ1bmN0aW9uLF9ub2RlMyk7aWYoY2hpbGRSZXN1bHQpe2NoaWxkUmVzdWx0LnVuc2hpZnQoX25vZGUzKTtyZXR1cm4gY2hpbGRSZXN1bHQ7fX19fX1yZXR1cm4gbnVsbDt9LyoqCiAgICog6YGN5Y6G5qCRCiAgICogQHBhcmFtIHRyZWUKICAgKiBAcGFyYW0gZm9yRWFjaEZ1bmN0aW9uIOimgeWvuee7k+eCuei/m+ihjOaTjeS9nOeahOWHveaVsO+8jOagvOW8j+S4uihub2RlLCBpbmRleCwgcGFyZW50Tm9kZSk9PnZvaWQKICAgKiBAcGFyYW0gcGFyZW50CiAgICoKICAgKiBAcHJpdmF0ZQogICAqL30se2tleToiX2ZvckVhY2hJbm5lciIsdmFsdWU6ZnVuY3Rpb24gX2ZvckVhY2hJbm5lcih0cmVlLGZvckVhY2hGdW5jdGlvbil7dmFyIHBhcmVudD1hcmd1bWVudHMubGVuZ3RoPjImJmFyZ3VtZW50c1syXSE9PXVuZGVmaW5lZD9hcmd1bWVudHNbMl06bnVsbDtpZih0cmVlKXsvL+mBjeWOhue7k+eCue+8jOWvuee7k+eCueaJp+ihjOaTjeS9nO+8jOW5tumAkuW9kuWtkOe7k+eCuQpmb3IodmFyIGk9MDtpPHRyZWUubGVuZ3RoO2krKyl7dmFyIF9ub2RlND10cmVlW2ldO2ZvckVhY2hGdW5jdGlvbihfbm9kZTQsaSxwYXJlbnQpO3RoaXMuX2ZvckVhY2hJbm5lcih0aGlzLmdldENoaWxkcmVuKF9ub2RlNCksZm9yRWFjaEZ1bmN0aW9uKTt9fXJldHVybiBudWxsO30vKioKICAgKiDojrflj5bnu5PngrnnmoTlgLwKICAgKiBAcGFyYW0geyp9IG5vZGUKICAgKi99LHtrZXk6ImdldE5vZGVEYXRhIix2YWx1ZTpmdW5jdGlvbiBnZXROb2RlRGF0YShub2RlKXtpZih0aGlzLmRhdGFHZXR0ZXIgaW5zdGFuY2VvZiBGdW5jdGlvbil7cmV0dXJuIHRoaXMuZGF0YUdldHRlcihub2RlKTt9ZWxzZXtyZXR1cm4gbm9kZVt0aGlzLmRhdGFHZXR0ZXJdO319LyoqCiAgICog6I635Y+W57uT54K555qE5a2Q57uT54K55YiX6KGoCiAgICogQHBhcmFtIHsqfSBub2RlCiAgICoKICAgKiBAcmV0dXJuIHtBcnJheX0KICAgKi99LHtrZXk6ImdldENoaWxkcmVuIix2YWx1ZTpmdW5jdGlvbiBnZXRDaGlsZHJlbihub2RlKXtpZih0aGlzLmNoaWxkcmVuR2V0dGVyIGluc3RhbmNlb2YgRnVuY3Rpb24pe3JldHVybiB0aGlzLmNoaWxkcmVuR2V0dGVyKG5vZGUpO31lbHNle3JldHVybiBub2RlW3RoaXMuY2hpbGRyZW5HZXR0ZXJdO319fSx7a2V5OiJfY3JlYXRlQ2hpbGRyZW4iLHZhbHVlOmZ1bmN0aW9uIF9jcmVhdGVDaGlsZHJlbihub2RlLGNoaWxkcmVuKXtpZih0aGlzLmNoaWxkcmVuQ3JlYXRlciBpbnN0YW5jZW9mIEZ1bmN0aW9uKXtyZXR1cm4gdGhpcy5jaGlsZHJlbkNyZWF0ZXIobm9kZSxjaGlsZHJlbik7fWVsc2V7bm9kZVt0aGlzLmNoaWxkcmVuQ3JlYXRlcl09Y2hpbGRyZW58fFtdO3JldHVybiBub2RlW3RoaXMuY2hpbGRyZW5DcmVhdGVyXTt9fX1dKTtyZXR1cm4gVHJlZUNvbnRyb2w7fSgpO2V4cG9ydCBkZWZhdWx0IFRyZWVDb250cm9sO2lmKHR5cGVvZiBUcmVlQ29udHJvbCE9PSd1bmRlZmluZWQnJiZUcmVlQ29udHJvbCYmVHJlZUNvbnRyb2w9PT1PYmplY3QoVHJlZUNvbnRyb2wpJiZPYmplY3QuaXNFeHRlbnNpYmxlKFRyZWVDb250cm9sKSl7T2JqZWN0LmRlZmluZVByb3BlcnR5KFRyZWVDb250cm9sLCdfX2ZpbGVtZXRhJyx7ZW51bWVyYWJsZTp0cnVlLGNvbmZpZ3VyYWJsZTp0cnVlLHZhbHVlOntuYW1lOiJUcmVlQ29udHJvbCIsZmlsZW5hbWU6InNyYy91dGlscy9UcmVlQ29udHJvbC50cyJ9fSk7fQ=="},{"version":3,"sources":["/Users/xujunjie/Documents/git/projectComponent/src/utils/TreeControl.ts"],"names":["TreeControl","dataGetter","childrenGetter","childrenCreater","Error","tree","equal","_filterInner","parentNode","result","i","length","item","push","filterChildren","getChildren","_createChildren","list","equalParent","innerListTree","parent","children","equalFunction","chain","_searchChainInner","searchParent","child","index","node","search","realIndex","Math","max","min","_removeInner","splice","forEachFunction","_forEachInner","forEach","mapFunction","_mapInner","newNode","childResult","unshift","Function"],"mappings":"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","sourcesContent":["type equalFunctionType<T> = (node: T, index: number, parentNode: T | null) => boolean;\n\n/**\n * 一个通用的树结构操作器，对源数据的结构没有要求\n * @author yinhunfeixue\n * @email yinhunfeixue@163.com\n */\nclass TreeControl<T extends { [key: string]: any }> {\n  private dataGetter: string | ((item: T) => any);\n  private childrenGetter: string | ((item: T) => T[]);\n  private childrenCreater: string | ((item: T, children?: T[]) => T[]);\n\n  /**\n   * 创建树控制器实例\n   * @param {String|Function} dataGetter 获取结点值的方法，为字符串或(node)=>object的函数\n   * @param {String|Function} childrenGetter 获取结点子结点列表的方法，为字符串或(node)=>object的函数\n   */\n  constructor(\n    dataGetter: string | ((item: T) => any) = 'value',\n    childrenGetter: string | ((item: T) => any[]) = 'children',\n    childrenCreater: string | ((item: T, children?: T[]) => any[]) = 'children',\n  ) {\n    if (!dataGetter) {\n      throw new Error('dataGetter need value');\n    } else if (!childrenGetter) {\n      throw new Error('childrenGetter need value');\n    } else {\n      this.dataGetter = dataGetter;\n      this.childrenGetter = childrenGetter;\n      this.childrenCreater = childrenCreater;\n    }\n  }\n\n  /**\n   * 过滤树\n   * @param tree 树\n   * @param equal 是否匹配的方法，返回true，表示结果中包含此结点及基子结点\n   */\n  public filter(tree: T[], equal: equalFunctionType<T>): T[] {\n    return this._filterInner(tree, equal, null);\n  }\n\n  private _filterInner(tree: T[], equal: equalFunctionType<T>, parentNode: T | null): T[] {\n    if (!tree) {\n      return [];\n    }\n    const result: T[] = [];\n    // 循环tree\n    // 对于每一项，如果equal返回true，添加到结果列表中；否则，递归子列表，如果递归的子列表>=0，添加到结果列表\n    for (let i = 0; i < tree.length; i++) {\n      const item = { ...(tree[i] as any) };\n      if (equal(item, i, parentNode)) {\n        result.push(item);\n      } else {\n        const filterChildren = this._filterInner(this.getChildren(item), equal, item);\n        if (filterChildren && filterChildren.length > 0) {\n          result.push(item);\n          this._createChildren(item, filterChildren);\n        }\n      }\n    }\n    return result;\n  }\n\n  /**\n   * 一维数组转换成树结构\n   * @param list\n   */\n  public listToTree(list: T[], equalParent: (node: T, parentNode: T | null) => boolean): T[] {\n    return this.innerListTree(list, equalParent, null);\n  }\n\n  private innerListTree(\n    list: T[],\n    equalParent: (node: T, parentNode: T | null) => boolean,\n    parent: T | null,\n  ): T[] {\n    if (!list) {\n      return [];\n    }\n    // 循环list，针对每一项item：使用equalParent判断parent是否是item的父结点\n    // 如果是，则添加到结果列表；并以item为父结点，查找子列表\n    // 否则，不处理\n    const result: T[] = [];\n    for (let i = 0; i < list.length; i++) {\n      const item = list[i];\n      if (equalParent(item, parent)) {\n        result.push(item);\n        const children = this.innerListTree(list, equalParent, item);\n        if (children && children.length) {\n          this._createChildren(item, children);\n        }\n      }\n    }\n    return result;\n  }\n\n  /**\n   * 搜索满足指定条件的第一个结点\n   * @param 树结点的数据\n   * @param 匹配函数\n   */\n  search(tree: T[], equalFunction: equalFunctionType<T>) {\n    let chain = this._searchChainInner(tree, equalFunction);\n    return chain && chain.length ? chain[chain.length - 1] : null;\n  }\n\n  /**\n   * 搜索满足指定条件的第一个结点的父结点\n   * @param tree 树\n   * @param equalFunction 匹配函数，格式为(node, index, parentNode)=>bool\n   */\n  searchParent(tree: T[], equalFunction: equalFunctionType<T>) {\n    let chain = this._searchChainInner(tree, equalFunction);\n    if (chain && chain.length >= 2) {\n      return chain[chain.length - 2];\n    }\n    return null;\n  }\n\n  /**\n   * 获取满足指定条件的第一个结点在父结点子列表中的位置，如果无父结点，或结点不存在，返回-1\n   * @param tree 树\n   * @param equalFunction 匹配函数，格式为(node, index, parentNode)=>bool\n   *\n   * @return {Number} 指定条件的结点所在的位置\n   */\n  getIndex(tree: T[], equalFunction: equalFunctionType<T>) {\n    let parent = this.searchParent(tree, equalFunction);\n    if (parent) {\n      let children = this.getChildren(parent);\n      for (let i = 0; i < children.length; i++) {\n        if (equalFunction(children[i], i, parent)) {\n          return i;\n        }\n      }\n    }\n    return -1;\n  }\n\n  addAt(tree: T[], equalFunction: equalFunctionType<T>, child: T, index = -1) {\n    let node = this.search(tree, equalFunction);\n    if (node) {\n      let children = this.getChildren(node);\n      if (!children) {\n        children = this._createChildren(node);\n      }\n\n      if (children) {\n        let realIndex = Math.max(0, Math.min(children.length, index));\n        children[realIndex] = child;\n      }\n    }\n  }\n\n  remove(tree: T[], equalFunction: equalFunctionType<T>) {\n    this._removeInner(tree, equalFunction);\n  }\n\n  /**\n   *\n   * @param tree\n   * @param equalFunction\n   */\n  _removeInner(tree: T[], equalFunction: equalFunctionType<T>, parent: T | null = null) {\n    if (tree) {\n      //遍历结点\n      for (let i = 0; i < tree.length; i++) {\n        let node = tree[i];\n        //如果当前结点符合被删除的条件，则删除；不符合，则递归子结点\n        if (equalFunction(node, i, parent)) {\n          tree.splice(i, 1);\n          i--;\n        } else {\n          this._removeInner(this.getChildren(node), equalFunction, node);\n        }\n      }\n    }\n  }\n\n  /**\n   * 搜索满足条件的第一个结点，并返回从一级结点到指定结点的数组，第一项是一级结点，最后一项是符合条件的结点\n   * @param tree 树\n   * @param equalFunction 匹配函数\n   */\n  searchChain(tree: T[], equalFunction: equalFunctionType<T>) {\n    return this._searchChainInner(tree, equalFunction);\n  }\n\n  /**\n   * 遍历树结点，并对每个结点执行回调函数\n   * @param {Array} tree 树\n   * @param {Function} forEachFunction 回调函数\n   */\n  forEach(tree: T[], forEachFunction: (node: T, index: number, parentNode: T | null) => void) {\n    this._forEachInner(tree, forEachFunction);\n  }\n\n  /**\n   * 查找所有符合条件的结点，并返回符合条件结点的一维数组\n   * @param tree 树\n   * @param equalFunction 匹配函数\n   */\n  find(tree: T[], equalFunction: equalFunctionType<T>) {\n    let result: T[] = [];\n    this.forEach(tree, (node, i, parent) => {\n      if (equalFunction(node, i, parent)) {\n        result.push(node);\n      }\n    });\n    return result;\n  }\n\n  /**\n   * 计算树的结点总数\n   * @param tree 树\n   */\n  count(tree: T[]) {\n    let result = 0;\n    this.forEach(tree, () => {\n      result++;\n    });\n    return result;\n  }\n\n  /**\n   * 遍历树，并创建和原结构一致的新树。新树的结点为原树结点调用函数处理后的值\n   *\n   * **注意**，新树不会自动创建子结点，需要在mapFunction中，把返回值和参数中的newChildren进行关联，例如result.children = newChildren\n   *\n   * @param tree\n   * @param {*} mapFunction 格式为(node, index, oldParent, newChildren)=>Object\n   */\n  map<W>(\n    tree: T[],\n    mapFunction: (node: T, index: number, oldParent: T | null, newChildren: W[] | null) => W,\n  ) {\n    return this._mapInner(tree, mapFunction);\n  }\n\n  /**\n   *\n   * @param {*} tree\n   * @param {*} mapFunction\n   * @param {*} parent\n   *\n   * @private\n   */\n  _mapInner<W>(\n    tree: T[],\n    mapFunction: (node: T, index: number, oldParent: T | null, newChildren: W[] | null) => W,\n    parent: T | null = null,\n  ) {\n    //循环树结点，并先递归子树，获取用mapFunction创建的新子树\n    //子树递归完成后，用mapFunction对当前结点创建新结点，并放到新树中\n    //把子树放到新结点的子列表中\n    if (tree) {\n      let result = [];\n      for (let i = 0; i < tree.length; i++) {\n        let node = tree[i];\n        let children = this._mapInner(this.getChildren(node), mapFunction, node);\n        let newNode = mapFunction(node, i, parent, children);\n        result.push(newNode);\n      }\n      return result;\n    }\n    return null;\n  }\n\n  /**\n   * 内部用于递归搜索结点链的函数\n   * @param tree 树\n   * @param equalFunction 匹配函数，格式为(node, index, parentNode)=>bool\n   * @param parent 父结点\n   *\n   * @private\n   *\n   * @return {Array} 从根结点当符合条件的结点的数组\n   */\n  private _searchChainInner(\n    tree: T[],\n    equalFunction: equalFunctionType<T>,\n    parent: T | null = null,\n  ): T[] | null {\n    if (tree) {\n      //循环树，如果有结点符合条件，则放到数组中返回\n      //如果结点不符合条件，但是有子结点，则递归子结点，如果从子结点中找到结点，把当前结点放到子结果中，一起返回\n      for (let i = 0; i < tree.length; i++) {\n        let node = tree[i];\n        if (equalFunction(node, i, parent)) {\n          return [node];\n        } else {\n          let children = this.getChildren(node);\n          if (children) {\n            let childResult = this._searchChainInner(children, equalFunction, node);\n            if (childResult) {\n              childResult.unshift(node);\n              return childResult;\n            }\n          }\n        }\n      }\n    }\n    return null;\n  }\n\n  /**\n   * 遍历树\n   * @param tree\n   * @param forEachFunction 要对结点进行操作的函数，格式为(node, index, parentNode)=>void\n   * @param parent\n   *\n   * @private\n   */\n  private _forEachInner(\n    tree: T[],\n    forEachFunction: (node: T, index: number, parentNode: T | null) => void,\n    parent = null,\n  ) {\n    if (tree) {\n      //遍历结点，对结点执行操作，并递归子结点\n      for (let i = 0; i < tree.length; i++) {\n        let node = tree[i];\n        forEachFunction(node, i, parent);\n        this._forEachInner(this.getChildren(node), forEachFunction);\n      }\n    }\n    return null;\n  }\n\n  /**\n   * 获取结点的值\n   * @param {*} node\n   */\n  getNodeData(node: T) {\n    if (this.dataGetter instanceof Function) {\n      return this.dataGetter(node);\n    } else {\n      return node[this.dataGetter];\n    }\n  }\n\n  /**\n   * 获取结点的子结点列表\n   * @param {*} node\n   *\n   * @return {Array}\n   */\n  getChildren(node: T) {\n    if (this.childrenGetter instanceof Function) {\n      return this.childrenGetter(node);\n    } else {\n      return node[this.childrenGetter];\n    }\n  }\n\n  _createChildren(node: T, children?: T[]) {\n    if (this.childrenCreater instanceof Function) {\n      return this.childrenCreater(node, children);\n    } else {\n      (node as any)[this.childrenCreater] = children || [];\n      return node[this.childrenCreater];\n    }\n  }\n}\n\nexport default TreeControl;\n"]}]}